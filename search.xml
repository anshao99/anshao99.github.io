<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Session VS Cookie</title>
      <link href="/2020/02/25/Session%20VS%20Cookie/"/>
      <url>/2020/02/25/Session%20VS%20Cookie/</url>
      
        <content type="html"><![CDATA[<h2 id="0-Session-VS-Cookie"><a href="#0-Session-VS-Cookie" class="headerlink" title="0. Session VS Cookie"></a>0. Session VS Cookie</h2><blockquote><p>HTTP协议</p><ul><li>无状态</li><li>短连接</li></ul><p><strong><em>长连接</em></strong></p><ul><li>即时通讯</li><li>实时数据</li></ul></blockquote><blockquote><ul><li>cookie：在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。</li><li>session:session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，但现在服务器已经发展至今，一些session信息还是绰绰有余的。</li><li>cookie和session结合使用：</li></ul></blockquote><p>web开发发展至今，cookie和session的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式：</p><ol><li>存储在服务端：通过cookie存储一个session_id，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。</li><li>将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。</li></ol><h2 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1. 闭包"></a>1. 闭包</h2><h3 id="1-1-如何访问其他函数内部数据？"><a href="#1-1-如何访问其他函数内部数据？" class="headerlink" title="1.1. 如何访问其他函数内部数据？"></a>1.1. 如何访问其他函数内部数据？</h3><h3 id="1-2-闭包概念"><a href="#1-2-闭包概念" class="headerlink" title="1.2. 闭包概念"></a>1.2. 闭包概念</h3><blockquote><p><strong><em>闭包就是指 一个可以访问其他函数内部数据的函数。</em></strong></p></blockquote><h3 id="1-3-闭包特点"><a href="#1-3-闭包特点" class="headerlink" title="1.3. 闭包特点"></a>1.3. 闭包特点</h3><ul><li>函数嵌套函数；outer函数和inner函数</li><li>内部函数可以使用外部函数的内部变量（形参）</li><li>内部inner函数 是 外部outer函数的返回值</li><li>函数中的局部变量在外部是不能被引用（保护函数内的变量安全）</li><li>外层函数一旦执行，就会创建新的闭包。而不同闭包之间的数据是独立的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="built_in">Math</span>.random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 使用外部函数的变量</span></span><br><span class="line">        <span class="keyword">return</span> m + n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function outer() &#123;</span></span><br><span class="line"><span class="comment">//   var n = Math.random();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   return function() &#123;</span></span><br><span class="line"><span class="comment">//     return n;</span></span><br><span class="line"><span class="comment">//   &#125;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> n, m;</span><br><span class="line">     n = <span class="built_in">Math</span>.random();</span><br><span class="line">     m = &#123; <span class="attr">name</span>: <span class="string">'m'</span> &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">         getN: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> n;</span><br><span class="line">         &#125;,</span><br><span class="line">         getM: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> m;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-闭包优缺点"><a href="#1-4-闭包优缺点" class="headerlink" title="1.4. 闭包优缺点"></a>1.4. 闭包优缺点</h3><ul><li>避免全局变量污染</li><li>将函数内部变量的值始终保存在内存中（缓存）</li><li>通过保护变量的安全实现 JS 私有属性和私有方法（不能被外部访问）</li><li>缺点：使用闭包，会增大内存的开销；如果滥用闭包，就会有可能造成内存泄漏的危险。</li></ul><blockquote><p><strong>内存泄漏</strong>： 计算机的内存被一点一点占满，从而不能在定义其他变量、数据…。这种现象叫做 “内存泄漏”。</p><p><strong>内存溢出</strong>： 存储数据所需要的内存空间，超过计算机所剩下的内存空间。此时在开辟内存时，就会有溢出。因此这样的现象被叫做“内存溢出”；</p></blockquote><h2 id="2-闭包缓存原理"><a href="#2-闭包缓存原理" class="headerlink" title="2. 闭包缓存原理"></a>2. 闭包缓存原理</h2><blockquote><p>内存管理：所有的高级语言中，都会有一个名为：GC 对象。由它来负责程序运行的内存管理。</p><ul><li>当需要创建变量时。开辟一定的内存空间来存储数据。（开辟）</li><li>在合适的时机下，将那些不在使用的数据所占用内存释放掉。（回收）</li></ul><p><strong>GC工作流程</strong>：GC工作前，内存中会有两个内存空间；分别叫做 <code>from</code>和 <code>to</code>。</p><ul><li>所有定义的数据、变量等，先在from内存空间去开辟，</li><li>当from空间被占满时，GC出来工作。</li><li>将from空间的数据，移植到to空间去，</li><li>GC造访to空间中的所有数据，查看是否已没有任何变量，对象使用了，</li><li>如果是的话，那么就将其所占用内存释放的（回收）</li><li>最后将在to空间中没有回收的数据，在移植会from空间。</li><li>直到from空间再次被占满，如此反复。</li></ul></blockquote><h3 id="2-1-垃圾回收机制"><a href="#2-1-垃圾回收机制" class="headerlink" title="2.1. 垃圾回收机制"></a>2.1. 垃圾回收机制</h3><ul><li>引用计数法：当 某一数据被创建时，此时计数 为 0.（问题：循环引用）<ul><li>当有某一变量或对象 使用了该数据，计数+1；</li><li>当某一变量或对象 不在使用该数据，计数-1；</li><li>当GC造访时，如果计数为0，就表示该数据没有被使用。因此要回收其所占内存。</li></ul></li><li>标记清除法：如果根root（window）出发，找不到任何一条路径可以到达某一数据（变量），那么说明该变量（数据）没有任何人使用。此时该数据被标记为“可清除”。<ul><li>当GC造访时，如果该数据被标记为“可清除”，那么就要回收其所占内存。</li></ul></li><li>异步标记清除法：利用多线程的优势，来解决传统标记清除法的性能问题。</li></ul><h2 id="3-闭包应用"><a href="#3-闭包应用" class="headerlink" title="3. 闭包应用"></a>3. 闭包应用</h2><ul><li>缓存</li><li>setTimeout 等传参问题</li><li>私有变量</li><li>模块化（块级作用域）IIFE</li></ul><h2 id="4-终极面试题"><a href="#4-终极面试题" class="headerlink" title="4. 终极面试题"></a>4. 终极面试题</h2><blockquote><ul><li>function showBiBao() {</li><li>for (var i = 0; i &lt; 5; i++) {</li><li>setTimeout(function timer() {</li><li>console.log(i);</li><li>}, 1000);</li><li>}</li><li>console.log(i);</li><li>}</li><li>// 会输出什么</li><li>showBiBao();</li></ul></blockquote><blockquote><p>-function func(n, o) {</p><ul><li>console.log(o);</li><li>return {</li><li>func: function(m) {</li><li>return func(m, n);</li><li>}</li><li>};</li><li>}</li></ul></blockquote><blockquote><ul><li>var a = func(0);</li><li>a.func(1);</li><li>a.func(2);</li><li>a.func(3);</li></ul></blockquote><blockquote><ul><li>var b = func(0)</li><li>.func(1)</li><li>.func(2)</li><li>.func(3);</li></ul></blockquote><p>var c = func(0).func(1);<br>c.func(2);<br>c.func(3);</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础语法</title>
      <link href="/2020/02/25/JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/02/25/JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript基础语法"><a href="#JavaScript基础语法" class="headerlink" title="JavaScript基础语法"></a>JavaScript基础语法</h2><ul><li><code>HTML</code> ：标记语言</li><li><code>JavaScript</code> ：编程语言</li></ul><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><h3 id="JavaScript发展历史（JS）"><a href="#JavaScript发展历史（JS）" class="headerlink" title="JavaScript发展历史（JS）"></a>JavaScript发展历史（JS）</h3><ol><li><p>1994年，网景公司(Netscape)发布了Navigator浏览器0.9版，这是世界上第一款比较成熟的网络浏览器，轰动一时。但是这是一款名副其实的浏览器–只能浏览页面，浏览器无法与用户互动,当时解决这个问题有两个办法，一个是采用现有的语言,许它们直接嵌入网页。另一个是发明一种全新的语言。<br> liveScript ==&gt; javaScript ==&gt; ECMAscript</p></li><li><p>1995年Sun公司将Oak语言改名为Java，正式向市场推出。Sun公司大肆宣传，许诺这种语言可以”一次编写，到处运     行”(Write Once, Run Anywhere)，它看上去很可能成为未来的主宰。</p></li><li><p>网景公司动了心，决定与Sun公司结成联盟</p></li><li><p>34岁的系统程序员Brendan Eich登场了。1995年4月，网景公司录用了他,他只用10天时间就把Javascript设计出来了。（多肽语言）</p></li><li><p>(1)借鉴C语言的基本语法; (2)借鉴Java语言的数据类型和内存管理; (3)借鉴Scheme语言，将函数提升到”第一等公民”(first class)的地位; (4)借鉴Self语言，使用基于原型(prototype)的继承机制。</p></li></ol><h2 id="JavaScript能干什么"><a href="#JavaScript能干什么" class="headerlink" title="JavaScript能干什么"></a>JavaScript能干什么</h2><ol><li>常见的网页效果【表单验证，轮播图。。。】</li><li>与H5配合实现游戏【水果忍者： <a href="http://www.jq22.com/demo/html5-fruit-ninja/】" target="_blank" rel="noopener">http://www.jq22.com/demo/html5-fruit-ninja/】</a></li><li>实现应用级别的程序【<a href="http://naotu.baidu.com】" target="_blank" rel="noopener">http://naotu.baidu.com】</a></li><li>实现统计效果【<a href="http://echarts.baidu.com/examples/】" target="_blank" rel="noopener">http://echarts.baidu.com/examples/】</a></li><li>地理定位等功能【<a href="http://lbsyun.baidu.com/jsdemo.htm#i4_5】" target="_blank" rel="noopener">http://lbsyun.baidu.com/jsdemo.htm#i4_5】</a></li><li>在线学编程【<a href="https://codecombat.163.com/play/】" target="_blank" rel="noopener">https://codecombat.163.com/play/】</a></li><li>js可以实现人工智能【面部识别】</li><li>。。。</li></ol><h2 id="JavaScript的组成"><a href="#JavaScript的组成" class="headerlink" title="JavaScript的组成"></a>JavaScript的组成</h2><ol><li>ECMASCRIPT: 定义了javascript的语法规范,描述了语言的基本语法和数据类型</li><li>BOM (Browser Object Model): 浏览器对象模型<ul><li>有一套成熟的可以操作浏览器的 API，通过 BOM 可以操作浏览器。比如： 弹出框、浏览器跳转、获取分辨率等</li></ul></li><li>DOM (Document Object Model): 文档对象模型<ul><li>有一套成熟的可以操作页面元素的 API，通过 DOM 可以操作页面中的元素。比如： 增加个 div，减少个 div，给div 换个位置等</li></ul></li></ol><p>总结： <strong>JS 就是通过固定的语法去操作 浏览器 和 标签结构 来实现网页上的各种效果</strong></p><h2 id="JavaScript代码的书写位置"><a href="#JavaScript代码的书写位置" class="headerlink" title="JavaScript代码的书写位置"></a>JavaScript代码的书写位置</h2><ul><li>和 <code>css</code> 一样，我们的 <code>js</code> 也可以有多种方式书写在页面上让其生效</li><li><code>js</code> 也有多种方式书写，分为 <strong>行内式</strong>， <strong>内嵌式</strong>，<strong>外链式</strong></li></ul><h2 id="行内式-JS-代码（不推荐）"><a href="#行内式-JS-代码（不推荐）" class="headerlink" title="行内式 JS 代码（不推荐）"></a>行内式 JS 代码（不推荐）</h2><ul><li>写在标签上的 js 代码需要依靠事件（行为）来触发</li></ul><!-- 写在 a 标签的 href 属性上 --><!-- <a href="javascript:alert('我是一个弹出层');">点击一下试试</a> --><!-- 写在其他元素上 --><!-- <div onclick="alert('我是一个弹出层')">点一下试试看</div> --><!--     注：onclick 是一个事件（点击事件），当点击元素的时候执行后面的 js 代码--><h2 id="内嵌式-JS-代码"><a href="#内嵌式-JS-代码" class="headerlink" title="内嵌式 JS 代码"></a>内嵌式 JS 代码</h2><ul><li>内嵌式的 js 代码会在页面打开的时候直接触发</li></ul><!-- 在 html 页面书写一个 script 标签，标签内部书写 js 代码 --><!-- <script type="text/javascript">    alert('我是一个弹出层')</script> --><!--     注：script 标签可以放在 head 里面也可以放在 body 里面--><h2 id="外链式-JS-代码（推荐）"><a href="#外链式-JS-代码（推荐）" class="headerlink" title="外链式 JS 代码（推荐）"></a>外链式 JS 代码（推荐）</h2><ul><li>外链式 js 代码只要引入了 html 页面，就会在页面打开的时候直接触发</li><li>新建一个 <code>.js</code> 后缀的文件，在文件内书写 js 代码，把写好的 js 文件引入 html 页面</li></ul><p>// 我是 index.js 文件</p><!-- 我是一个 html 文件 --><!-- 通过 script 标签的 src 属性，把写好的 js 文件引入页面 --><!-- 一个页面可以引入多个 js 文件 --><h2 id="JS-中的注释"><a href="#JS-中的注释" class="headerlink" title="JS 中的注释"></a>JS 中的注释</h2><ul><li>学习一个语言，先学习一个语言的注释，因为注释是给我们自己看的，也是给开发人员看的</li><li>写好一个注释，有利于我们以后阅读代码</li></ul><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><ul><li>一般就是用来描述下面一行代码的作用</li><li>可以直接写两个 <code>/</code> ，也可以按 <code>ctrl + /</code><br>我是一个单行注释</li></ul><p>下面代码表示在浏览器里面出现一个弹出层<br>alert(‘我是一个弹出层’)</p><h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><ul><li>一般用来写一大段话，或者注释一段代码</li><li>可以直接写 <code>/**/</code> 然后在两个星号中间写注释，也可以按 <code>shift + alt + a</code><br>  我是一个多行注释<br>  注释的代码不会执行</li></ul><h2 id="变量（重点）"><a href="#变量（重点）" class="headerlink" title="变量（重点）"></a>变量（重点）</h2><ul><li>变量指的是在程序中保存数据的一个容器</li><li>变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据</li><li>也就是说，我们向内存中存储了一个数据，然后要给这个数据起一个名字，为了是我们以后再次找到他</li><li>语法： <code>var 变量名 = 值</code></li></ul><h2 id="定义变量及赋值"><a href="#定义变量及赋值" class="headerlink" title="定义变量及赋值"></a>定义变量及赋值</h2><p>// 定义一个变量<br>var num;</p><p>// 给一个变量赋值<br>num = 100;</p><p>// 定义一个变量的同时给其赋值<br>var num2 = 200;</p><ul><li>注意：<ol><li>一个变量名只能存储一个值</li><li>当再次给一个变量赋值的时候，前面一次的值就没有了</li><li>变量名称区分大小写（JS 区分大小写）</li></ol></li></ul><h2 id="变量的命名规则和命名规范"><a href="#变量的命名规则和命名规范" class="headerlink" title="变量的命名规则和命名规范"></a>变量的命名规则和命名规范</h2><ul><li>规则： 必须遵守的，不遵守就是错<ol><li>一个变量名称可以由 <strong>数字</strong>、<strong>字母</strong>、<strong>英文下划线（_）</strong>、<strong>美元符号（$）</strong> 组成</li><li>严格区分大小写</li><li>不能由数字开头，不要使用中文汉字命名</li><li>不能是 <strong>保留字</strong> 或者 <strong>关键字</strong></li><li>不要出现空格</li></ol></li><li>规范： 建议遵守的（开发者默认），不遵守不会报错<ol><li>变量名尽量有意义（语义化）</li><li>遵循驼峰命名规则，由多个单词组成的时候，从第二个单词开始首字母大写</li></ol></li></ul><h2 id="数据类型（重点）"><a href="#数据类型（重点）" class="headerlink" title="数据类型（重点）"></a>数据类型（重点）</h2><ul><li>是指我们存储在内存中的数据的类型</li><li>我们通常分为两大类 <strong>基本数据类型</strong> 和 <strong>复杂数据类型</strong></li></ul><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ol><li>数值类型（number）<ul><li>一切数字都是数值类型（包括二进制，十进制，十六进制等）</li><li>NaN（not a number），一个非数字</li></ul></li><li>字符串类型（string）<ul><li>被引号包裹的所有内容（可以是单引号也可以是双引号）</li></ul></li><li>布尔类型（boolean）<ul><li>只有两个（true 或者 false）</li></ul></li><li>null类型（null）<ul><li>只有一个，就是 null，表示空的意思</li></ul></li><li>undefined类型（undefined）<ul><li>只有一个，就是 undefined，表示没有值的意思</li></ul></li></ol><h2 id="复杂数据类型（暂时先不讲）"><a href="#复杂数据类型（暂时先不讲）" class="headerlink" title="复杂数据类型（暂时先不讲）"></a>复杂数据类型（暂时先不讲）</h2><ol><li>对象类型（object）</li><li>函数类型（function）</li><li>。。。</li></ol><h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><ul><li>既然已经把数据分开了类型，那么我们就要知道我们存储的数据是一个什么类型的数据</li><li>使用 <code>typeof</code> 关键字来进行判断</li></ul><p>// 第一种使用方式<br>var n1 = 100;<br>console.log(typeof n1);</p><p>// 第二种使用方式<br>var s1 = ‘abcdefg’;<br>console.log(typeof(s1));</p><h2 id="判断一个变量是不是数字"><a href="#判断一个变量是不是数字" class="headerlink" title="判断一个变量是不是数字"></a>判断一个变量是不是数字</h2><ul><li>可以使用 <code>isNaN</code> 这个方法来判断一个变量是不是数字</li><li><code>isNaN</code> ：is not a number</li></ul><p>// 如果变量是一个数字<br>var n1 = 100;<br>console.log(isNaN(n1)); //=&gt; false</p><p>// 如果变量不是一个数字<br>var s1 = ‘Jack’<br>console.log(isNaN(s1)); //=&gt; true</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ul><li>数据类型之间的转换，比如数字转成字符串，字符串转成布尔，布尔转成数字等</li></ul><h2 id="其他数据类型转成数值"><a href="#其他数据类型转成数值" class="headerlink" title="其他数据类型转成数值"></a>其他数据类型转成数值</h2><ol><li><code>Number(变量)</code><ul><li>可以把一个变量强制转换成数值类型</li><li>可以转换小数，会保留小数</li><li>可以转换布尔值</li><li>遇到不可转换的都会返回 NaN</li></ul></li><li><code>parseInt(变量)</code><ul><li>从第一位开始检查，是数字就转换，知道一个不是数字的内容</li><li>开头就不是数字，那么直接返回 NaN</li><li>不认识小数点，只能保留整数</li></ul></li><li><code>parseFloat(变量)</code><ul><li>从第一位开始检查，是数字就转换，知道一个不是数字的内容</li><li>开头就不是数字，那么直接返回 NaN</li><li>认识一次小数点</li></ul></li><li>除了加法以外的数学运算<ul><li>运算符两边都是可运算数字才行</li><li>如果运算符任何一遍不是一个可运算数字，那么就会返回 NaN</li><li>加法不可以用</li></ul></li></ol><h2 id="其他数据类型转成字符串"><a href="#其他数据类型转成字符串" class="headerlink" title="其他数据类型转成字符串"></a>其他数据类型转成字符串</h2><ol><li><code>变量.toString()</code><ul><li>有一些数据类型不能使用 <code>toString()</code> 方法，比如 undefined 和 null</li></ul></li><li><code>String(变量)</code><ul><li>所有数据类型都可以</li></ul></li><li>使用加法运算<ul><li>在 JS 里面，<code>+</code> 由两个含义</li><li>字符串拼接： 只要 <code>+</code> 任意一边是字符串，就会进行字符串拼接</li><li>加法运算：只有 <code>+</code> 两边都是数字的时候，才会进行数学运算</li></ul></li></ol><h2 id="其他数据类型转成布尔"><a href="#其他数据类型转成布尔" class="headerlink" title="其他数据类型转成布尔"></a>其他数据类型转成布尔</h2><ol><li><code>Boolean(变量)</code><ul><li>在 js 中，只有 <code>&#39;&#39;</code>、<code>0</code>、<code>null</code>、<code>undefined</code>、<code>NaN</code>，这些是 false，其余都是 true</li></ul></li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>就是在代码里面进行运算的时候使用的符号，不光只是数学运算，我们在 js 里面还有很多的运算方式</li></ul><h2 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h2><ol><li><code>+</code><ul><li>只有符号两边都是数字的时候才会进行加法运算</li><li>只要符号任意一边是字符串类型，就会进行字符串拼接</li></ul></li><li><code>-</code><ul><li>会执行减法运算</li><li>会自动把两边都转换成数字进行运算</li></ul></li><li><code>*</code><ul><li>会执行乘法运算</li><li>会自动把两边都转换成数字进行运算</li></ul></li><li><code>/</code><ul><li>会执行除法运算</li><li>会自动把两边都转换成数字进行运算</li></ul></li><li><code>%</code><ul><li>会执行取余运算</li><li>会自动把两边都转换成数字进行运算</li></ul></li></ol><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ol><li><p><code>=</code></p><ul><li>就是把 <code>=</code> 右边的赋值给等号左边的变量名</li><li><code>var num = 100</code></li><li>就是把 100 赋值给 num 变量</li><li>那么 num 变量的值就是 100</li></ul></li><li><p><code>+=</code></p></li></ol><p>   var a = 10;<br>   a += 10;<br>   console.log(a); //=&gt; 20</p><ul><li><code>a += 10</code> 等价于 <code>a = a + 10</code></li></ul><ol start="3"><li><code>-=</code></li></ol><p>   var a = 10;<br>   a -= 10;<br>   console.log(a); //=&gt; 0</p><ul><li><code>a -= 10</code> 等价于 <code>a = a - 10</code></li></ul><ol start="4"><li><code>*=</code></li></ol><p>   var a = 10;<br>   a *= 10;<br>   console.log(a); //=&gt; 100</p><ul><li><code>a *= 10</code> 等价于 <code>a = a * 10</code></li></ul><ol start="5"><li><code>/+</code></li></ol><p>   var a = 10;<br>   a /= 10;<br>   console.log(a); //=&gt; 1</p><ul><li><code>a /= 10</code> 等价于 <code>a = a / 10</code></li></ul><ol start="6"><li><code>%=</code></li></ol><p>   var a = 10;<br>   a %= 10;<br>   console.log(a); //=&gt; 0</p><ul><li><code>a %= 10</code> 等价于 <code>a = a % 10</code></li></ul><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ol><li><code>==</code><ul><li>比较符号两边的值是否相等，不管数据类型</li><li><code>1 == &#39;1&#39;</code></li><li>两个的值是一样的，所以得到 true</li></ul></li><li><code>===</code><ul><li>比较符号两边的值和数据类型是否都相等</li><li><code>1 === &#39;1&#39;</code></li><li>两个值虽然一样，但是因为数据类型不一样，所以得到 false</li></ul></li><li><code>!=</code><ul><li>比较符号两边的值是否不等</li><li><code>1 != &#39;1&#39;</code></li><li>因为两边的值是相等的，所以比较他们不等的时候得到 false</li></ul></li><li><code>!==</code><ul><li>比较符号两边的数据类型和值是否不等</li><li><code>1 !== &#39;1&#39;</code></li><li>因为两边的数据类型确实不一样，所以得到 true</li></ul></li><li><code>&gt;=</code><ul><li>比较左边的值是否 大于或等于 右边的值</li><li><code>1 &gt;= 1</code>  true</li><li><code>1 &gt;= 0</code>  true</li><li><code>1 &gt;= 2</code>  false</li></ul></li><li><code>&lt;=</code><ul><li>比较左边的值是否 小于或等于 右边的值</li><li><code>1 &lt;= 2</code>  true</li><li><code>1 &lt;= 1</code>  true</li><li><code>1 &lt;= 0</code>  false </li></ul></li><li><code>&gt;</code><ul><li>比较左边的值是否 大于 右边的值</li><li><code>1 &gt; 0</code>  true</li><li><code>1 &gt; 1</code>  false</li><li><code>1 &gt; 2</code>  false</li></ul></li><li><code>&lt;</code><ul><li>比较左边的值是否 小于 右边的值</li><li><code>1 &lt; 2</code>  true</li><li><code>1 &lt; 1</code> false</li><li><code>1 &lt; 0</code> false</li></ul></li></ol><p>##逻辑运算符 </p><ol><li><code>&amp;&amp;</code><ul><li>进行 且 的运算</li><li>符号左边必须为 true 并且右边也是 true，才会返回 true</li><li>只要有一边不是 true，那么就会返回 false</li><li><code>true &amp;&amp; true</code>  true</li><li><code>true &amp;&amp; false</code>  false</li><li><code>false &amp;&amp; true</code>  false</li><li><code>false &amp;&amp; false</code>  false</li></ul></li><li><code>||</code><ul><li>进行 或 的运算</li><li>符号的左边为 true 或者右边为 true，都会返回 true</li><li>只有两边都是 false 的时候才会返回 false</li><li><code>true || true</code>  true</li><li><code>true || false</code>  true</li><li><code>false || true</code>  true</li><li><code>false || false</code>  false</li></ul></li><li><code>!</code><ul><li>进行 取反 运算</li><li>本身是 true 的，会变成 false</li><li>本身是 false 的，会变成 true</li><li><code>!true</code>  false</li><li><code>!false</code>  true</li></ul></li></ol><h2 id="自增自减运算符（一元运算符）"><a href="#自增自减运算符（一元运算符）" class="headerlink" title="自增自减运算符（一元运算符）"></a>自增自减运算符（一元运算符）</h2><ol><li><p><code>++</code></p><ul><li><p>进行自增运算</p></li><li><p>分成两种，<strong>前置++</strong> 和 <strong>后置++</strong></p></li><li><p>前置++，会先把值自动 +1，在返回</p></li></ul></li></ol><pre><code>var a = 10;console.log(++a);// 会返回 11，并且把 a 的值变成 11</code></pre><ul><li>后置++，会先把值返回，在自动+1</li></ul><pre><code>var a = 10;console.log(a++);// 会返回 10，然后把 a 的值变成 11</code></pre><ol start="2"><li><p><code>--</code></p><ul><li>进行自减运算</li><li>分成两种，<strong>前置–</strong> 和 <strong>后置–</strong></li><li>和 <code>++</code> 运算符道理一样</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/25/hello-world/"/>
      <url>/2020/02/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="hello-hexo"><a href="#hello-hexo" class="headerlink" title="hello hexo"></a>hello hexo</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
